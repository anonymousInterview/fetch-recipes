### Summary: Include screen shots or a video of your app highlighting its features

ðŸ‘‹ Welcome to the FetchRecipes app. The FetchRecipes app features:
- A list of recipes
- Pull to refresh list functionality
- Functional error and empty states
- Accessibility as a first class citizen: voice over, dynamic type, appropriate tap targets, and dark mode
 
| Default | Empty State | Error State |
|-|-|-|
|![Default](/screenshots/default.png "Default")|![Empty](/screenshots/empty.png "Empty")|![Error](/screenshots/error.png "Error")|

| Pull to Refresh | Dynamic Type | Code Coverage |
|-|-|-|
|![Refresh](/screenshots/refresh.png "Refresh")|![Dynamic Type](/screenshots/dynamic_type.png "Dynamic Type")|![Code Coverage](/screenshots/coverage.png "Code Coverage")|

### Focus Areas: What specific areas of the project did you prioritize? Why did you choose to focus on these areas?
 
#### Modularization
Modularization enforces separation of responsibilities. I've created two modules:
Recipes and Networking. The Recipes feature module holds domain knowledge 
over everything recipe related. From services to views, it knows how to display
a recipe list. The Recipe module depends on the foundational Networking module. 
The networking module owns the networking layer. The includes caching and 
an HTTP Client. It also includes an asynchronous image loader accompanied with a view
that implements the loader. The Recipe module is able to depend on the Networking
module for all its networking needs, without knowing any implementation details.
We're able to do this through protocol interfaces (e.g. HTTPClient).

#### Efficient Network Usage
One of the take-home requirements was efficient network usage. I've built a small
data caching system that supports both in-memory and disk retrieval of images.
Respecting a user's device is a huge priority when building a consumer applications,
so the cache has a size limit and evicts data when it is full. The cache does this
through a Least Recently Used (LRU) caching policy.

Additionally, keeping an on disk cache up to date with an in memory cache can 
require a lot of writing to disk. To minimize writes, we debounce write requests.
This allows us to batch updates to the in-memory cache.

#### Dependency Injection
Our modules allow us to easily define functional boundaries and dependencies. This
is exemplified in `FetchRecipesApp`. The app imports a few dependencies and
instantiates the `RecipesView`. All dependencies are explicitly defined and injected.
These dependencies have protocol interfaces that allow us to extract
implementation details. Using these interfaces increases testability by allowing
us to mock dependencies easily.

#### Accessibility
Consumer applications should maintain high accessibility standards 
(such as WCAG 2.2). In this project, I've prioritized voice over, dynamic type, 
appropriately sized tap targets, and dark mode.


### Time Spent: Approximately how long did you spend working on this project? How did you allocate your time?

I spent ~12 hours on this project.

6: Image Caching
2: UI
3: Testing
1: Documentation

### Trade-offs and Decisions: Did you make any significant trade-offs in your approach?



### Weakest Part of the Project: What do you think is the weakest part of your project?

When building a production grade app, one decides what architecture
to build the app with. In this app, I've used a MVVM approach. Given
there wasn't any navigational requirements, I didn't setup a
routing system. In other apps, I've used the Coordinator pattern to extract 
routing logic from the view layer. Recent codebases I've worked in have
been UIKit/SwiftUI based and Coordinators work well with UINavigationControllers.
It'd be interesting to explore the Coordinator pattern using a SwiftUI
NavigationStack.

### Additional Information: Is there anything else we should know? Feel free to share any insights or constraints you encountered.

This was fun project. Thanks for the exercise!
